**Task 0**

Написать метод, принимающий массив целых чисел и распечатывающий массив в обратной последовательности.
```
{1, 4, 3, 6, 7} -> распечатывает [7, 6, 3, 4, 1]
```
Перегрузить метод, если в него приходит индекс, то часть массива слева до этого индекса распечатывается в обычном порядке,
а начиная с этого индекса в обратном:

```
{1, 4, 3, 6, 7} + индекс 2 - > распечатывает [1, 4, 7, 6, 3]
```

Еще одна перегрузка: метод принимает массив и булевый флаг.
Если флаг == true -> печатает массив в обратном порядке
Если флаг == false -> печатает массив в прямом порядке



**Task 1**

Написать метод, принимающий на вход целое число.
Метод должен вывести на экран 2 в степени этоЧисло

_класс Math для нахождения степени числа использовать **нельзя** ;)_

**Task 2** _опционально_

Написать свой метод copyOfArray, дублирующий функционал метода Arrays.copyOf()

на вход принимает массив целых чисел и число - длинну нового массива.
Метод должен создать и распечатать массив заданной в параметрах длинны. В начало массива должны быть скопированы элементы из входящего массива:

```
{0, 1, 2, 3, 4 , 5, 6} -> copyOfArray(array, 3) -> вывод на печать {0, 1, 2}
```

_Arrays.copyOf() использовать нельзя. Суть задачи - написать собственную реализацию этого метода_


**Task 3 со звездочкой** _**опционально**_

Дано:
Два отсортированных массива целых чисел.
Вам нужно найти элемент, который будет находиться на k-й позиции в объединенном отсортированном массиве.
```
Массив 1 - {100, 112, 256, 349, 770}
Массив 2 - {72, 86, 113, 119, 265, 445, 892}
k = 7
```
Вывод : 256

Можно такой вывод:
```
72, 86, 100, 112, 113, 119, 256
Искомое число: 256
```

Объединенный отсортированный массив был бы такой (выводить, формировать его не обязательно) -
```
[72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892]
```

7-й элемент (по счету) этого массива хранит значение 256.